// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: device.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Device_DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Device_DeviceInfo.DeviceType {
    get {return _storage._type ?? .dtUnknown}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var mac: String {
    get {return _storage._mac ?? String()}
    set {_uniqueStorage()._mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return _storage._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {_uniqueStorage()._mac = nil}

  var firmware: Device_DeviceInfo.FirmwareInfo {
    get {return _storage._firmware ?? Device_DeviceInfo.FirmwareInfo()}
    set {_uniqueStorage()._firmware = newValue}
  }
  /// Returns true if `firmware` has been explicitly set.
  var hasFirmware: Bool {return _storage._firmware != nil}
  /// Clears the value of `firmware`. Subsequent reads from it will return its default value.
  mutating func clearFirmware() {_uniqueStorage()._firmware = nil}

  var subType: Device_DeviceInfo.DeviceSubType {
    get {return _storage._subType ?? .dstUnknown}
    set {_uniqueStorage()._subType = newValue}
  }
  /// Returns true if `subType` has been explicitly set.
  var hasSubType: Bool {return _storage._subType != nil}
  /// Clears the value of `subType`. Subsequent reads from it will return its default value.
  mutating func clearSubType() {_uniqueStorage()._subType = nil}

  var model: String {
    get {return _storage._model ?? String()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {_uniqueStorage()._model = nil}

  var uuid: String {
    get {return _storage._uuid ?? String()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var screenInfo: Device_DeviceInfo.DeviceScreenInfo {
    get {return _storage._screenInfo ?? Device_DeviceInfo.DeviceScreenInfo()}
    set {_uniqueStorage()._screenInfo = newValue}
  }
  /// Returns true if `screenInfo` has been explicitly set.
  var hasScreenInfo: Bool {return _storage._screenInfo != nil}
  /// Clears the value of `screenInfo`. Subsequent reads from it will return its default value.
  mutating func clearScreenInfo() {_uniqueStorage()._screenInfo = nil}

  var application: Application_ApplicationInfo {
    get {return _storage._application ?? Application_ApplicationInfo()}
    set {_uniqueStorage()._application = newValue}
  }
  /// Returns true if `application` has been explicitly set.
  var hasApplication: Bool {return _storage._application != nil}
  /// Clears the value of `application`. Subsequent reads from it will return its default value.
  mutating func clearApplication() {_uniqueStorage()._application = nil}

  var vendor: String {
    get {return _storage._vendor ?? String()}
    set {_uniqueStorage()._vendor = newValue}
  }
  /// Returns true if `vendor` has been explicitly set.
  var hasVendor: Bool {return _storage._vendor != nil}
  /// Clears the value of `vendor`. Subsequent reads from it will return its default value.
  mutating func clearVendor() {_uniqueStorage()._vendor = nil}

  var supportedDrm: Device_DeviceInfo.SupportedDRM {
    get {return _storage._supportedDrm ?? Device_DeviceInfo.SupportedDRM()}
    set {_uniqueStorage()._supportedDrm = newValue}
  }
  /// Returns true if `supportedDrm` has been explicitly set.
  var hasSupportedDrm: Bool {return _storage._supportedDrm != nil}
  /// Clears the value of `supportedDrm`. Subsequent reads from it will return its default value.
  mutating func clearSupportedDrm() {_uniqueStorage()._supportedDrm = nil}

  var guid: String {
    get {return _storage._guid ?? String()}
    set {_uniqueStorage()._guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  var hasGuid: Bool {return _storage._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  mutating func clearGuid() {_uniqueStorage()._guid = nil}

  var system: String {
    get {return _storage._system ?? String()}
    set {_uniqueStorage()._system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  var hasSystem: Bool {return _storage._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  mutating func clearSystem() {_uniqueStorage()._system = nil}

  var systemInfo: Device_DeviceInfo.SystemInfo {
    get {return _storage._systemInfo ?? Device_DeviceInfo.SystemInfo()}
    set {_uniqueStorage()._systemInfo = newValue}
  }
  /// Returns true if `systemInfo` has been explicitly set.
  var hasSystemInfo: Bool {return _storage._systemInfo != nil}
  /// Clears the value of `systemInfo`. Subsequent reads from it will return its default value.
  mutating func clearSystemInfo() {_uniqueStorage()._systemInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Platform: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0
    case web // = 1
    case mobile // = 2
    case smartTv // = 3

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .web
      case 2: self = .mobile
      case 3: self = .smartTv
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .web: return 1
      case .mobile: return 2
      case .smartTv: return 3
      }
    }

  }

  enum DeviceType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case dtUnknown // = 0
    case dtDib120 // = 1
    case dtIptvPlayer // = 2
    case dtMag200 // = 7
    case dtMag250Micro // = 8
    case dtMag250Mini // = 9
    case dtHimediaHd600A // = 10
    case dtAndroidPlayer // = 11
    case dtStbEmul // = 12
    case dtSmartTv // = 13
    case dtINext // = 14
    case dtM3U // = 15
    case dtAndroidTv // = 16
    case dtIosPlayer // = 17
    case dtMacOsPlayer // = 18
    case dtKiviTv // = 19
    case dtGxStb // = 20
    case dtNomiTv // = 21
    case dtWebBrowser // = 22
    case dtErgoTv // = 23
    case dtAppleTv // = 24
    case dtXbox // = 25

    init() {
      self = .dtUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dtUnknown
      case 1: self = .dtDib120
      case 2: self = .dtIptvPlayer
      case 7: self = .dtMag200
      case 8: self = .dtMag250Micro
      case 9: self = .dtMag250Mini
      case 10: self = .dtHimediaHd600A
      case 11: self = .dtAndroidPlayer
      case 12: self = .dtStbEmul
      case 13: self = .dtSmartTv
      case 14: self = .dtINext
      case 15: self = .dtM3U
      case 16: self = .dtAndroidTv
      case 17: self = .dtIosPlayer
      case 18: self = .dtMacOsPlayer
      case 19: self = .dtKiviTv
      case 20: self = .dtGxStb
      case 21: self = .dtNomiTv
      case 22: self = .dtWebBrowser
      case 23: self = .dtErgoTv
      case 24: self = .dtAppleTv
      case 25: self = .dtXbox
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .dtUnknown: return 0
      case .dtDib120: return 1
      case .dtIptvPlayer: return 2
      case .dtMag200: return 7
      case .dtMag250Micro: return 8
      case .dtMag250Mini: return 9
      case .dtHimediaHd600A: return 10
      case .dtAndroidPlayer: return 11
      case .dtStbEmul: return 12
      case .dtSmartTv: return 13
      case .dtINext: return 14
      case .dtM3U: return 15
      case .dtAndroidTv: return 16
      case .dtIosPlayer: return 17
      case .dtMacOsPlayer: return 18
      case .dtKiviTv: return 19
      case .dtGxStb: return 20
      case .dtNomiTv: return 21
      case .dtWebBrowser: return 22
      case .dtErgoTv: return 23
      case .dtAppleTv: return 24
      case .dtXbox: return 25
      }
    }

  }

  enum DeviceSubType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case dstUnknown // = 0
    case dstLg // = 1
    case dstSamsung // = 2
    case dstPhilips // = 3
    case dstToshiba // = 4
    case dstInext // = 5
    case dstInfomir // = 6
    case dstKivi // = 7
    case dstNomi // = 8
    case dstErgo // = 9
    case dstVestel // = 10
    case dstVewd // = 11
    case dstFoxxum // = 12
    case dstZeasn // = 13
    case dstSony // = 14
    case dstRomsat // = 15
    case dstSamsungMobile // = 16
    case dstAiwa // = 17
    case dstLiberton // = 18
    case dstHuaweiMobile // = 19
    case dstPresetApp // = 20
    case dstComfyStore // = 21
    case dstPanasonic // = 22
    case dstArcelik // = 23
    case dstHisense // = 24
    case dstOzoneHd // = 25
    case dstFireTv // = 26
    case dstRealme // = 27
    case dstGazer // = 28
    case dstTlc // = 29
    case dstTcl // = 30
    case dstOrsay // = 31

    init() {
      self = .dstUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dstUnknown
      case 1: self = .dstLg
      case 2: self = .dstSamsung
      case 3: self = .dstPhilips
      case 4: self = .dstToshiba
      case 5: self = .dstInext
      case 6: self = .dstInfomir
      case 7: self = .dstKivi
      case 8: self = .dstNomi
      case 9: self = .dstErgo
      case 10: self = .dstVestel
      case 11: self = .dstVewd
      case 12: self = .dstFoxxum
      case 13: self = .dstZeasn
      case 14: self = .dstSony
      case 15: self = .dstRomsat
      case 16: self = .dstSamsungMobile
      case 17: self = .dstAiwa
      case 18: self = .dstLiberton
      case 19: self = .dstHuaweiMobile
      case 20: self = .dstPresetApp
      case 21: self = .dstComfyStore
      case 22: self = .dstPanasonic
      case 23: self = .dstArcelik
      case 24: self = .dstHisense
      case 25: self = .dstOzoneHd
      case 26: self = .dstFireTv
      case 27: self = .dstRealme
      case 28: self = .dstGazer
      case 29: self = .dstTlc
      case 30: self = .dstTcl
      case 31: self = .dstOrsay
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .dstUnknown: return 0
      case .dstLg: return 1
      case .dstSamsung: return 2
      case .dstPhilips: return 3
      case .dstToshiba: return 4
      case .dstInext: return 5
      case .dstInfomir: return 6
      case .dstKivi: return 7
      case .dstNomi: return 8
      case .dstErgo: return 9
      case .dstVestel: return 10
      case .dstVewd: return 11
      case .dstFoxxum: return 12
      case .dstZeasn: return 13
      case .dstSony: return 14
      case .dstRomsat: return 15
      case .dstSamsungMobile: return 16
      case .dstAiwa: return 17
      case .dstLiberton: return 18
      case .dstHuaweiMobile: return 19
      case .dstPresetApp: return 20
      case .dstComfyStore: return 21
      case .dstPanasonic: return 22
      case .dstArcelik: return 23
      case .dstHisense: return 24
      case .dstOzoneHd: return 25
      case .dstFireTv: return 26
      case .dstRealme: return 27
      case .dstGazer: return 28
      case .dstTlc: return 29
      case .dstTcl: return 30
      case .dstOrsay: return 31
      }
    }

  }

  enum AspectRatio: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case arUnknown // = 0
    case ar169 // = 1
    case ar43 // = 2
    case ar189 // = 3
    case ar219 // = 4
    case ar3918 // = 5

    init() {
      self = .arUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .arUnknown
      case 1: self = .ar169
      case 2: self = .ar43
      case 3: self = .ar189
      case 4: self = .ar219
      case 5: self = .ar3918
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .arUnknown: return 0
      case .ar169: return 1
      case .ar43: return 2
      case .ar189: return 3
      case .ar219: return 4
      case .ar3918: return 5
      }
    }

  }

  enum NetworkConnectionType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case nctUnknown // = 0
    case nctEthernet // = 1
    case nctWiFi // = 2
    case nctCellular // = 3

    init() {
      self = .nctUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nctUnknown
      case 1: self = .nctEthernet
      case 2: self = .nctWiFi
      case 3: self = .nctCellular
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .nctUnknown: return 0
      case .nctEthernet: return 1
      case .nctWiFi: return 2
      case .nctCellular: return 3
      }
    }

  }

  struct DeviceScreenInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: Int32 {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    mutating func clearWidth() {self._width = nil}

    var height: Int32 {
      get {return _height ?? 0}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {self._height = nil}

    var aspectRatio: Device_DeviceInfo.AspectRatio {
      get {return _aspectRatio ?? .arUnknown}
      set {_aspectRatio = newValue}
    }
    /// Returns true if `aspectRatio` has been explicitly set.
    var hasAspectRatio: Bool {return self._aspectRatio != nil}
    /// Clears the value of `aspectRatio`. Subsequent reads from it will return its default value.
    mutating func clearAspectRatio() {self._aspectRatio = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _width: Int32? = nil
    fileprivate var _height: Int32? = nil
    fileprivate var _aspectRatio: Device_DeviceInfo.AspectRatio? = nil
  }

  struct FirmwareModule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var versionCode: Int32 {
      get {return _versionCode ?? 0}
      set {_versionCode = newValue}
    }
    /// Returns true if `versionCode` has been explicitly set.
    var hasVersionCode: Bool {return self._versionCode != nil}
    /// Clears the value of `versionCode`. Subsequent reads from it will return its default value.
    mutating func clearVersionCode() {self._versionCode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _versionCode: Int32? = nil
  }

  struct FirmwareInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var versionCode: Int32 {
      get {return _versionCode ?? 0}
      set {_versionCode = newValue}
    }
    /// Returns true if `versionCode` has been explicitly set.
    var hasVersionCode: Bool {return self._versionCode != nil}
    /// Clears the value of `versionCode`. Subsequent reads from it will return its default value.
    mutating func clearVersionCode() {self._versionCode = nil}

    var versionString: String {
      get {return _versionString ?? String()}
      set {_versionString = newValue}
    }
    /// Returns true if `versionString` has been explicitly set.
    var hasVersionString: Bool {return self._versionString != nil}
    /// Clears the value of `versionString`. Subsequent reads from it will return its default value.
    mutating func clearVersionString() {self._versionString = nil}

    var modules: [Device_DeviceInfo.FirmwareModule] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _versionCode: Int32? = nil
    fileprivate var _versionString: String? = nil
  }

  struct SupportedDRM {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var aes128: Bool {
      get {return _aes128 ?? false}
      set {_aes128 = newValue}
    }
    /// Returns true if `aes128` has been explicitly set.
    var hasAes128: Bool {return self._aes128 != nil}
    /// Clears the value of `aes128`. Subsequent reads from it will return its default value.
    mutating func clearAes128() {self._aes128 = nil}

    var widevineModular: Bool {
      get {return _widevineModular ?? false}
      set {_widevineModular = newValue}
    }
    /// Returns true if `widevineModular` has been explicitly set.
    var hasWidevineModular: Bool {return self._widevineModular != nil}
    /// Clears the value of `widevineModular`. Subsequent reads from it will return its default value.
    mutating func clearWidevineModular() {self._widevineModular = nil}

    var widevineClassic: Bool {
      get {return _widevineClassic ?? false}
      set {_widevineClassic = newValue}
    }
    /// Returns true if `widevineClassic` has been explicitly set.
    var hasWidevineClassic: Bool {return self._widevineClassic != nil}
    /// Clears the value of `widevineClassic`. Subsequent reads from it will return its default value.
    mutating func clearWidevineClassic() {self._widevineClassic = nil}

    var playReady: Bool {
      get {return _playReady ?? false}
      set {_playReady = newValue}
    }
    /// Returns true if `playReady` has been explicitly set.
    var hasPlayReady: Bool {return self._playReady != nil}
    /// Clears the value of `playReady`. Subsequent reads from it will return its default value.
    mutating func clearPlayReady() {self._playReady = nil}

    var fairPlay: Bool {
      get {return _fairPlay ?? false}
      set {_fairPlay = newValue}
    }
    /// Returns true if `fairPlay` has been explicitly set.
    var hasFairPlay: Bool {return self._fairPlay != nil}
    /// Clears the value of `fairPlay`. Subsequent reads from it will return its default value.
    mutating func clearFairPlay() {self._fairPlay = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _aes128: Bool? = nil
    fileprivate var _widevineModular: Bool? = nil
    fileprivate var _widevineClassic: Bool? = nil
    fileprivate var _playReady: Bool? = nil
    fileprivate var _fairPlay: Bool? = nil
  }

  struct SystemInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var networkConnectionType: Device_DeviceInfo.NetworkConnectionType {
      get {return _networkConnectionType ?? .nctUnknown}
      set {_networkConnectionType = newValue}
    }
    /// Returns true if `networkConnectionType` has been explicitly set.
    var hasNetworkConnectionType: Bool {return self._networkConnectionType != nil}
    /// Clears the value of `networkConnectionType`. Subsequent reads from it will return its default value.
    mutating func clearNetworkConnectionType() {self._networkConnectionType = nil}

    var osVersion: String {
      get {return _osVersion ?? String()}
      set {_osVersion = newValue}
    }
    /// Returns true if `osVersion` has been explicitly set.
    var hasOsVersion: Bool {return self._osVersion != nil}
    /// Clears the value of `osVersion`. Subsequent reads from it will return its default value.
    mutating func clearOsVersion() {self._osVersion = nil}

    var totalMemory: Int32 {
      get {return _totalMemory ?? 0}
      set {_totalMemory = newValue}
    }
    /// Returns true if `totalMemory` has been explicitly set.
    var hasTotalMemory: Bool {return self._totalMemory != nil}
    /// Clears the value of `totalMemory`. Subsequent reads from it will return its default value.
    mutating func clearTotalMemory() {self._totalMemory = nil}

    var hardware: String {
      get {return _hardware ?? String()}
      set {_hardware = newValue}
    }
    /// Returns true if `hardware` has been explicitly set.
    var hasHardware: Bool {return self._hardware != nil}
    /// Clears the value of `hardware`. Subsequent reads from it will return its default value.
    mutating func clearHardware() {self._hardware = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _networkConnectionType: Device_DeviceInfo.NetworkConnectionType? = nil
    fileprivate var _osVersion: String? = nil
    fileprivate var _totalMemory: Int32? = nil
    fileprivate var _hardware: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Device_DeviceInfo.Platform: CaseIterable {
  // Support synthesized by the compiler.
}

extension Device_DeviceInfo.DeviceType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Device_DeviceInfo.DeviceSubType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Device_DeviceInfo.AspectRatio: CaseIterable {
  // Support synthesized by the compiler.
}

extension Device_DeviceInfo.NetworkConnectionType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "device"

extension Device_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "mac"),
    3: .same(proto: "firmware"),
    4: .standard(proto: "sub_type"),
    5: .same(proto: "model"),
    6: .same(proto: "uuid"),
    7: .standard(proto: "screen_info"),
    8: .same(proto: "application"),
    9: .same(proto: "vendor"),
    10: .standard(proto: "supported_drm"),
    11: .same(proto: "guid"),
    12: .same(proto: "system"),
    13: .standard(proto: "system_info"),
  ]

  fileprivate class _StorageClass {
    var _type: Device_DeviceInfo.DeviceType? = nil
    var _mac: String? = nil
    var _firmware: Device_DeviceInfo.FirmwareInfo? = nil
    var _subType: Device_DeviceInfo.DeviceSubType? = nil
    var _model: String? = nil
    var _uuid: String? = nil
    var _screenInfo: Device_DeviceInfo.DeviceScreenInfo? = nil
    var _application: Application_ApplicationInfo? = nil
    var _vendor: String? = nil
    var _supportedDrm: Device_DeviceInfo.SupportedDRM? = nil
    var _guid: String? = nil
    var _system: String? = nil
    var _systemInfo: Device_DeviceInfo.SystemInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _mac = source._mac
      _firmware = source._firmware
      _subType = source._subType
      _model = source._model
      _uuid = source._uuid
      _screenInfo = source._screenInfo
      _application = source._application
      _vendor = source._vendor
      _supportedDrm = source._supportedDrm
      _guid = source._guid
      _system = source._system
      _systemInfo = source._systemInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._firmware, !v.isInitialized {return false}
      if let v = _storage._screenInfo, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._mac) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._firmware) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._subType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._model) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._screenInfo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._application) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._vendor) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._supportedDrm) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._guid) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._system) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._systemInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._mac {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._firmware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._subType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._model {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._uuid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._screenInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._application {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._vendor {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._supportedDrm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._guid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._system {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._systemInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Device_DeviceInfo, rhs: Device_DeviceInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._mac != rhs_storage._mac {return false}
        if _storage._firmware != rhs_storage._firmware {return false}
        if _storage._subType != rhs_storage._subType {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._screenInfo != rhs_storage._screenInfo {return false}
        if _storage._application != rhs_storage._application {return false}
        if _storage._vendor != rhs_storage._vendor {return false}
        if _storage._supportedDrm != rhs_storage._supportedDrm {return false}
        if _storage._guid != rhs_storage._guid {return false}
        if _storage._system != rhs_storage._system {return false}
        if _storage._systemInfo != rhs_storage._systemInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device_DeviceInfo.Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Undefined"),
    1: .same(proto: "Web"),
    2: .same(proto: "Mobile"),
    3: .same(proto: "SmartTV"),
  ]
}

extension Device_DeviceInfo.DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DT_Unknown"),
    1: .same(proto: "DT_DIB_120"),
    2: .same(proto: "DT_IPTV_Player"),
    7: .same(proto: "DT_MAG200"),
    8: .same(proto: "DT_MAG250_Micro"),
    9: .same(proto: "DT_MAG250_Mini"),
    10: .same(proto: "DT_Himedia_HD600A"),
    11: .same(proto: "DT_Android_Player"),
    12: .same(proto: "DT_STB_Emul"),
    13: .same(proto: "DT_SmartTV"),
    14: .same(proto: "DT_iNext"),
    15: .same(proto: "DT_M3U"),
    16: .same(proto: "DT_AndroidTV"),
    17: .same(proto: "DT_IOS_Player"),
    18: .same(proto: "DT_MacOS_Player"),
    19: .same(proto: "DT_Kivi_TV"),
    20: .same(proto: "DT_GX_STB"),
    21: .same(proto: "DT_NOMI_TV"),
    22: .same(proto: "DT_Web_Browser"),
    23: .same(proto: "DT_ERGO_TV"),
    24: .same(proto: "DT_AppleTV"),
    25: .same(proto: "DT_Xbox"),
  ]
}

extension Device_DeviceInfo.DeviceSubType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DST_Unknown"),
    1: .same(proto: "DST_LG"),
    2: .same(proto: "DST_SAMSUNG"),
    3: .same(proto: "DST_PHILIPS"),
    4: .same(proto: "DST_TOSHIBA"),
    5: .same(proto: "DST_INEXT"),
    6: .same(proto: "DST_INFOMIR"),
    7: .same(proto: "DST_KIVI"),
    8: .same(proto: "DST_NOMI"),
    9: .same(proto: "DST_ERGO"),
    10: .same(proto: "DST_VESTEL"),
    11: .same(proto: "DST_VEWD"),
    12: .same(proto: "DST_FOXXUM"),
    13: .same(proto: "DST_ZEASN"),
    14: .same(proto: "DST_SONY"),
    15: .same(proto: "DST_ROMSAT"),
    16: .same(proto: "DST_SAMSUNG_MOBILE"),
    17: .same(proto: "DST_AIWA"),
    18: .same(proto: "DST_LIBERTON"),
    19: .same(proto: "DST_HUAWEI_MOBILE"),
    20: .same(proto: "DST_PRESET_APP"),
    21: .same(proto: "DST_COMFY_STORE"),
    22: .same(proto: "DST_PANASONIC"),
    23: .same(proto: "DST_ARCELIK"),
    24: .same(proto: "DST_HISENSE"),
    25: .same(proto: "DST_OZONE_HD"),
    26: .same(proto: "DST_FIRE_TV"),
    27: .same(proto: "DST_REALME"),
    28: .same(proto: "DST_GAZER"),
    29: .same(proto: "DST_TLC"),
    30: .same(proto: "DST_TCL"),
    31: .same(proto: "DST_ORSAY"),
  ]
}

extension Device_DeviceInfo.AspectRatio: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AR_Unknown"),
    1: .same(proto: "AR_16_9"),
    2: .same(proto: "AR_4_3"),
    3: .same(proto: "AR_18_9"),
    4: .same(proto: "AR_21_9"),
    5: .same(proto: "AR_39_18"),
  ]
}

extension Device_DeviceInfo.NetworkConnectionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NCT_Unknown"),
    1: .same(proto: "NCT_Ethernet"),
    2: .same(proto: "NCT_WiFi"),
    3: .same(proto: "NCT_Cellular"),
  ]
}

extension Device_DeviceInfo.DeviceScreenInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Device_DeviceInfo.protoMessageName + ".DeviceScreenInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "aspectRatio"),
  ]

  public var isInitialized: Bool {
    if self._width == nil {return false}
    if self._height == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._aspectRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._aspectRatio {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Device_DeviceInfo.DeviceScreenInfo, rhs: Device_DeviceInfo.DeviceScreenInfo) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._aspectRatio != rhs._aspectRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device_DeviceInfo.FirmwareModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Device_DeviceInfo.protoMessageName + ".FirmwareModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "versionCode"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._versionCode == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._versionCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._versionCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Device_DeviceInfo.FirmwareModule, rhs: Device_DeviceInfo.FirmwareModule) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._versionCode != rhs._versionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device_DeviceInfo.FirmwareInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Device_DeviceInfo.protoMessageName + ".FirmwareInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versionCode"),
    2: .same(proto: "versionString"),
    3: .same(proto: "modules"),
  ]

  public var isInitialized: Bool {
    if self._versionCode == nil {return false}
    if self._versionString == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.modules) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._versionCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._versionString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._versionCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._versionString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Device_DeviceInfo.FirmwareInfo, rhs: Device_DeviceInfo.FirmwareInfo) -> Bool {
    if lhs._versionCode != rhs._versionCode {return false}
    if lhs._versionString != rhs._versionString {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device_DeviceInfo.SupportedDRM: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Device_DeviceInfo.protoMessageName + ".SupportedDRM"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aes_128"),
    2: .standard(proto: "widevine_modular"),
    3: .standard(proto: "widevine_classic"),
    4: .standard(proto: "play_ready"),
    5: .standard(proto: "fair_play"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._aes128) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._widevineModular) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._widevineClassic) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._playReady) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._fairPlay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._aes128 {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._widevineModular {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._widevineClassic {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._playReady {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._fairPlay {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Device_DeviceInfo.SupportedDRM, rhs: Device_DeviceInfo.SupportedDRM) -> Bool {
    if lhs._aes128 != rhs._aes128 {return false}
    if lhs._widevineModular != rhs._widevineModular {return false}
    if lhs._widevineClassic != rhs._widevineClassic {return false}
    if lhs._playReady != rhs._playReady {return false}
    if lhs._fairPlay != rhs._fairPlay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device_DeviceInfo.SystemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Device_DeviceInfo.protoMessageName + ".SystemInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "network_connection_type"),
    2: .standard(proto: "os_version"),
    3: .standard(proto: "total_memory"),
    4: .same(proto: "hardware"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._networkConnectionType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._osVersion) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._totalMemory) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._hardware) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._networkConnectionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._osVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._totalMemory {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._hardware {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Device_DeviceInfo.SystemInfo, rhs: Device_DeviceInfo.SystemInfo) -> Bool {
    if lhs._networkConnectionType != rhs._networkConnectionType {return false}
    if lhs._osVersion != rhs._osVersion {return false}
    if lhs._totalMemory != rhs._totalMemory {return false}
    if lhs._hardware != rhs._hardware {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
