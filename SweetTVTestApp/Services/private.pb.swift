// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: private.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TvService_StreamSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var streamHost: TvService_IPPort {
    get {return _streamHost ?? TvService_IPPort()}
    set {_streamHost = newValue}
  }
  /// Returns true if `streamHost` has been explicitly set.
  var hasStreamHost: Bool {return self._streamHost != nil}
  /// Clears the value of `streamHost`. Subsequent reads from it will return its default value.
  mutating func clearStreamHost() {self._streamHost = nil}

  var controlHost: TvService_IPPort {
    get {return _controlHost ?? TvService_IPPort()}
    set {_controlHost = newValue}
  }
  /// Returns true if `controlHost` has been explicitly set.
  var hasControlHost: Bool {return self._controlHost != nil}
  /// Clears the value of `controlHost`. Subsequent reads from it will return its default value.
  mutating func clearControlHost() {self._controlHost = nil}

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _streamHost: TvService_IPPort? = nil
  fileprivate var _controlHost: TvService_IPPort? = nil
  fileprivate var _url: String? = nil
}

struct TvService_ChannelSources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idChannel: Int32 {
    get {return _idChannel ?? 0}
    set {_idChannel = newValue}
  }
  /// Returns true if `idChannel` has been explicitly set.
  var hasIDChannel: Bool {return self._idChannel != nil}
  /// Clears the value of `idChannel`. Subsequent reads from it will return its default value.
  mutating func clearIDChannel() {self._idChannel = nil}

  var idOffset: Int32 {
    get {return _idOffset ?? 0}
    set {_idOffset = newValue}
  }
  /// Returns true if `idOffset` has been explicitly set.
  var hasIDOffset: Bool {return self._idOffset != nil}
  /// Clears the value of `idOffset`. Subsequent reads from it will return its default value.
  mutating func clearIDOffset() {self._idOffset = nil}

  var idCompany: Int32 {
    get {return _idCompany ?? 0}
    set {_idCompany = newValue}
  }
  /// Returns true if `idCompany` has been explicitly set.
  var hasIDCompany: Bool {return self._idCompany != nil}
  /// Clears the value of `idCompany`. Subsequent reads from it will return its default value.
  mutating func clearIDCompany() {self._idCompany = nil}

  var udpMulticastGroup: [TvService_StreamSource] = []

  var sudpMulticastGroup: [TvService_StreamSource] = []

  var udpStreamer: [TvService_StreamSource] = []

  var sudpStreamer: [TvService_StreamSource] = []

  var udpHTTPStreamer: [TvService_StreamSource] = []

  var sudpHTTPStreamer: [TvService_StreamSource] = []

  var cacheServer: [TvService_StreamSource] = []

  var hlsHTTPStreamer: [TvService_StreamSource] = []

  var hlsTimeshiftHTTPStreamer: [TvService_StreamSource] = []

  var hlsDrmHTTPSStreamer: [TvService_StreamSource] = []

  var dashDrmHTTPSStreamer: [TvService_StreamSource] = []

  var hlsAesHTTPSStreamer: [TvService_StreamSource] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _idChannel: Int32? = nil
  fileprivate var _idOffset: Int32? = nil
  fileprivate var _idCompany: Int32? = nil
}

struct TvService_ChannelSorting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var idChannel: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _name: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tv_service"

extension TvService_StreamSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "stream_host"),
    3: .standard(proto: "control_host"),
    4: .same(proto: "url"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._streamHost == nil {return false}
    if let v = self._streamHost, !v.isInitialized {return false}
    if let v = self._controlHost, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamHost) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._controlHost) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._streamHost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._controlHost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_StreamSource, rhs: TvService_StreamSource) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._streamHost != rhs._streamHost {return false}
    if lhs._controlHost != rhs._controlHost {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_ChannelSources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelSources"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_channel"),
    2: .standard(proto: "id_offset"),
    10: .standard(proto: "id_company"),
    3: .standard(proto: "udp_multicast_group"),
    4: .standard(proto: "sudp_multicast_group"),
    5: .standard(proto: "udp_streamer"),
    6: .standard(proto: "sudp_streamer"),
    7: .standard(proto: "udp_http_streamer"),
    8: .standard(proto: "sudp_http_streamer"),
    9: .standard(proto: "cache_server"),
    11: .standard(proto: "hls_http_streamer"),
    12: .standard(proto: "hls_timeshift_http_streamer"),
    13: .standard(proto: "hls_drm_https_streamer"),
    14: .standard(proto: "dash_drm_https_streamer"),
    15: .standard(proto: "hls_aes_https_streamer"),
  ]

  public var isInitialized: Bool {
    if self._idChannel == nil {return false}
    if self._idOffset == nil {return false}
    if self._idCompany == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.udpMulticastGroup) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sudpMulticastGroup) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.udpStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sudpStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.udpHTTPStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sudpHTTPStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cacheServer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.hlsHTTPStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.hlsTimeshiftHTTPStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.hlsDrmHTTPSStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.dashDrmHTTPSStreamer) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.hlsAesHTTPSStreamer) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._idChannel) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._idOffset) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.udpMulticastGroup) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sudpMulticastGroup) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.udpStreamer) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.sudpStreamer) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.udpHTTPStreamer) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.sudpHTTPStreamer) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.cacheServer) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._idCompany) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.hlsHTTPStreamer) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.hlsTimeshiftHTTPStreamer) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.hlsDrmHTTPSStreamer) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.dashDrmHTTPSStreamer) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.hlsAesHTTPSStreamer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._idChannel {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._idOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if !self.udpMulticastGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.udpMulticastGroup, fieldNumber: 3)
    }
    if !self.sudpMulticastGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sudpMulticastGroup, fieldNumber: 4)
    }
    if !self.udpStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.udpStreamer, fieldNumber: 5)
    }
    if !self.sudpStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sudpStreamer, fieldNumber: 6)
    }
    if !self.udpHTTPStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.udpHTTPStreamer, fieldNumber: 7)
    }
    if !self.sudpHTTPStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sudpHTTPStreamer, fieldNumber: 8)
    }
    if !self.cacheServer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cacheServer, fieldNumber: 9)
    }
    if let v = self._idCompany {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    }
    if !self.hlsHTTPStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hlsHTTPStreamer, fieldNumber: 11)
    }
    if !self.hlsTimeshiftHTTPStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hlsTimeshiftHTTPStreamer, fieldNumber: 12)
    }
    if !self.hlsDrmHTTPSStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hlsDrmHTTPSStreamer, fieldNumber: 13)
    }
    if !self.dashDrmHTTPSStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dashDrmHTTPSStreamer, fieldNumber: 14)
    }
    if !self.hlsAesHTTPSStreamer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hlsAesHTTPSStreamer, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_ChannelSources, rhs: TvService_ChannelSources) -> Bool {
    if lhs._idChannel != rhs._idChannel {return false}
    if lhs._idOffset != rhs._idOffset {return false}
    if lhs._idCompany != rhs._idCompany {return false}
    if lhs.udpMulticastGroup != rhs.udpMulticastGroup {return false}
    if lhs.sudpMulticastGroup != rhs.sudpMulticastGroup {return false}
    if lhs.udpStreamer != rhs.udpStreamer {return false}
    if lhs.sudpStreamer != rhs.sudpStreamer {return false}
    if lhs.udpHTTPStreamer != rhs.udpHTTPStreamer {return false}
    if lhs.sudpHTTPStreamer != rhs.sudpHTTPStreamer {return false}
    if lhs.cacheServer != rhs.cacheServer {return false}
    if lhs.hlsHTTPStreamer != rhs.hlsHTTPStreamer {return false}
    if lhs.hlsTimeshiftHTTPStreamer != rhs.hlsTimeshiftHTTPStreamer {return false}
    if lhs.hlsDrmHTTPSStreamer != rhs.hlsDrmHTTPSStreamer {return false}
    if lhs.dashDrmHTTPSStreamer != rhs.dashDrmHTTPSStreamer {return false}
    if lhs.hlsAesHTTPSStreamer != rhs.hlsAesHTTPSStreamer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_ChannelSorting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelSorting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "id_channel"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.idChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.idChannel.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.idChannel, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_ChannelSorting, rhs: TvService_ChannelSorting) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs.idChannel != rhs.idChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
