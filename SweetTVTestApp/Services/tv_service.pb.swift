// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tv_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TvService_Voucher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String {
    get {return _code ?? String()}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  mutating func clearCode() {self._code = nil}

  var activationDate: UInt64 {
    get {return _activationDate ?? 0}
    set {_activationDate = newValue}
  }
  /// Returns true if `activationDate` has been explicitly set.
  var hasActivationDate: Bool {return self._activationDate != nil}
  /// Clears the value of `activationDate`. Subsequent reads from it will return its default value.
  mutating func clearActivationDate() {self._activationDate = nil}

  var expirationDate: UInt64 {
    get {return _expirationDate ?? 0}
    set {_expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  var hasExpirationDate: Bool {return self._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  mutating func clearExpirationDate() {self._expirationDate = nil}

  var packageID: UInt32 {
    get {return _packageID ?? 0}
    set {_packageID = newValue}
  }
  /// Returns true if `packageID` has been explicitly set.
  var hasPackageID: Bool {return self._packageID != nil}
  /// Clears the value of `packageID`. Subsequent reads from it will return its default value.
  mutating func clearPackageID() {self._packageID = nil}

  var tariffID: UInt32 {
    get {return _tariffID ?? 0}
    set {_tariffID = newValue}
  }
  /// Returns true if `tariffID` has been explicitly set.
  var hasTariffID: Bool {return self._tariffID != nil}
  /// Clears the value of `tariffID`. Subsequent reads from it will return its default value.
  mutating func clearTariffID() {self._tariffID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _code: String? = nil
  fileprivate var _activationDate: UInt64? = nil
  fileprivate var _expirationDate: UInt64? = nil
  fileprivate var _packageID: UInt32? = nil
  fileprivate var _tariffID: UInt32? = nil
}

struct TvService_OpenStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var channelID: Int32 {
    get {return _channelID ?? 0}
    set {_channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return self._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {self._channelID = nil}

  var offsetID: Int32 {
    get {return _offsetID ?? 1}
    set {_offsetID = newValue}
  }
  /// Returns true if `offsetID` has been explicitly set.
  var hasOffsetID: Bool {return self._offsetID != nil}
  /// Clears the value of `offsetID`. Subsequent reads from it will return its default value.
  mutating func clearOffsetID() {self._offsetID = nil}

  var acceptScheme: [TvService_StreamScheme] = []

  var firstBatchSize: UInt32 {
    get {return _firstBatchSize ?? 0}
    set {_firstBatchSize = newValue}
  }
  /// Returns true if `firstBatchSize` has been explicitly set.
  var hasFirstBatchSize: Bool {return self._firstBatchSize != nil}
  /// Clears the value of `firstBatchSize`. Subsequent reads from it will return its default value.
  mutating func clearFirstBatchSize() {self._firstBatchSize = nil}

  var epgID: Int32 {
    get {return _epgID ?? 0}
    set {_epgID = newValue}
  }
  /// Returns true if `epgID` has been explicitly set.
  var hasEpgID: Bool {return self._epgID != nil}
  /// Clears the value of `epgID`. Subsequent reads from it will return its default value.
  mutating func clearEpgID() {self._epgID = nil}

  var multistream: Bool {
    get {return _multistream ?? false}
    set {_multistream = newValue}
  }
  /// Returns true if `multistream` has been explicitly set.
  var hasMultistream: Bool {return self._multistream != nil}
  /// Clears the value of `multistream`. Subsequent reads from it will return its default value.
  mutating func clearMultistream() {self._multistream = nil}

  var previewMode: Bool {
    get {return _previewMode ?? false}
    set {_previewMode = newValue}
  }
  /// Returns true if `previewMode` has been explicitly set.
  var hasPreviewMode: Bool {return self._previewMode != nil}
  /// Clears the value of `previewMode`. Subsequent reads from it will return its default value.
  mutating func clearPreviewMode() {self._previewMode = nil}

  var pinCode: Bool {
    get {return _pinCode ?? false}
    set {_pinCode = newValue}
  }
  /// Returns true if `pinCode` has been explicitly set.
  var hasPinCode: Bool {return self._pinCode != nil}
  /// Clears the value of `pinCode`. Subsequent reads from it will return its default value.
  mutating func clearPinCode() {self._pinCode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
  fileprivate var _channelID: Int32? = nil
  fileprivate var _offsetID: Int32? = nil
  fileprivate var _firstBatchSize: UInt32? = nil
  fileprivate var _epgID: Int32? = nil
  fileprivate var _multistream: Bool? = nil
  fileprivate var _previewMode: Bool? = nil
  fileprivate var _pinCode: Bool? = nil
}

struct TvService_OpenStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: TvService_OpenStreamResponse.Result {
    get {return _result ?? .ok}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var scheme: TvService_StreamScheme {
    get {return _scheme ?? .multicastUdp}
    set {_scheme = newValue}
  }
  /// Returns true if `scheme` has been explicitly set.
  var hasScheme: Bool {return self._scheme != nil}
  /// Clears the value of `scheme`. Subsequent reads from it will return its default value.
  mutating func clearScheme() {self._scheme = nil}

  var multicastGroup: TvService_IPPort {
    get {return _multicastGroup ?? TvService_IPPort()}
    set {_multicastGroup = newValue}
  }
  /// Returns true if `multicastGroup` has been explicitly set.
  var hasMulticastGroup: Bool {return self._multicastGroup != nil}
  /// Clears the value of `multicastGroup`. Subsequent reads from it will return its default value.
  mutating func clearMulticastGroup() {self._multicastGroup = nil}

  var httpStream: TvService_HttpStreamer {
    get {return _httpStream ?? TvService_HttpStreamer()}
    set {_httpStream = newValue}
  }
  /// Returns true if `httpStream` has been explicitly set.
  var hasHTTPStream: Bool {return self._httpStream != nil}
  /// Clears the value of `httpStream`. Subsequent reads from it will return its default value.
  mutating func clearHTTPStream() {self._httpStream = nil}

  var unicastStream: TvService_UnicastStreamer {
    get {return _unicastStream ?? TvService_UnicastStreamer()}
    set {_unicastStream = newValue}
  }
  /// Returns true if `unicastStream` has been explicitly set.
  var hasUnicastStream: Bool {return self._unicastStream != nil}
  /// Clears the value of `unicastStream`. Subsequent reads from it will return its default value.
  mutating func clearUnicastStream() {self._unicastStream = nil}

  var cacheServer: TvService_CacheServer {
    get {return _cacheServer ?? TvService_CacheServer()}
    set {_cacheServer = newValue}
  }
  /// Returns true if `cacheServer` has been explicitly set.
  var hasCacheServer: Bool {return self._cacheServer != nil}
  /// Clears the value of `cacheServer`. Subsequent reads from it will return its default value.
  mutating func clearCacheServer() {self._cacheServer = nil}

  var streamID: Int32 {
    get {return _streamID ?? 0}
    set {_streamID = newValue}
  }
  /// Returns true if `streamID` has been explicitly set.
  var hasStreamID: Bool {return self._streamID != nil}
  /// Clears the value of `streamID`. Subsequent reads from it will return its default value.
  mutating func clearStreamID() {self._streamID = nil}

  var updateInterval: UInt32 {
    get {return _updateInterval ?? 60}
    set {_updateInterval = newValue}
  }
  /// Returns true if `updateInterval` has been explicitly set.
  var hasUpdateInterval: Bool {return self._updateInterval != nil}
  /// Clears the value of `updateInterval`. Subsequent reads from it will return its default value.
  mutating func clearUpdateInterval() {self._updateInterval = nil}

  var licenseServer: String {
    get {return _licenseServer ?? String()}
    set {_licenseServer = newValue}
  }
  /// Returns true if `licenseServer` has been explicitly set.
  var hasLicenseServer: Bool {return self._licenseServer != nil}
  /// Clears the value of `licenseServer`. Subsequent reads from it will return its default value.
  mutating func clearLicenseServer() {self._licenseServer = nil}

  var mesh: Bool {
    get {return _mesh ?? false}
    set {_mesh = newValue}
  }
  /// Returns true if `mesh` has been explicitly set.
  var hasMesh: Bool {return self._mesh != nil}
  /// Clears the value of `mesh`. Subsequent reads from it will return its default value.
  mutating func clearMesh() {self._mesh = nil}

  var contentKey: String {
    get {return _contentKey ?? String()}
    set {_contentKey = newValue}
  }
  /// Returns true if `contentKey` has been explicitly set.
  var hasContentKey: Bool {return self._contentKey != nil}
  /// Clears the value of `contentKey`. Subsequent reads from it will return its default value.
  mutating func clearContentKey() {self._contentKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1
    case notFound // = 2
    case deny // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      case 2: self = .notFound
      case 3: self = .deny
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      case .notFound: return 2
      case .deny: return 3
      }
    }

  }

  init() {}

  fileprivate var _result: TvService_OpenStreamResponse.Result? = nil
  fileprivate var _scheme: TvService_StreamScheme? = nil
  fileprivate var _multicastGroup: TvService_IPPort? = nil
  fileprivate var _httpStream: TvService_HttpStreamer? = nil
  fileprivate var _unicastStream: TvService_UnicastStreamer? = nil
  fileprivate var _cacheServer: TvService_CacheServer? = nil
  fileprivate var _streamID: Int32? = nil
  fileprivate var _updateInterval: UInt32? = nil
  fileprivate var _licenseServer: String? = nil
  fileprivate var _mesh: Bool? = nil
  fileprivate var _contentKey: String? = nil
}

#if swift(>=4.2)

extension TvService_OpenStreamResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_UpdateStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var streamID: Int32 {
    get {return _streamID ?? 0}
    set {_streamID = newValue}
  }
  /// Returns true if `streamID` has been explicitly set.
  var hasStreamID: Bool {return self._streamID != nil}
  /// Clears the value of `streamID`. Subsequent reads from it will return its default value.
  mutating func clearStreamID() {self._streamID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
  fileprivate var _streamID: Int32? = nil
}

struct TvService_UpdateStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: TvService_UpdateStreamResponse.Result {
    get {return _result ?? .ok}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1
    case reopenStream // = 2
    case notFound // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      case 2: self = .reopenStream
      case 3: self = .notFound
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      case .reopenStream: return 2
      case .notFound: return 3
      }
    }

  }

  init() {}

  fileprivate var _result: TvService_UpdateStreamResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_UpdateStreamResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_CloseStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var streamID: Int32 {
    get {return _streamID ?? 0}
    set {_streamID = newValue}
  }
  /// Returns true if `streamID` has been explicitly set.
  var hasStreamID: Bool {return self._streamID != nil}
  /// Clears the value of `streamID`. Subsequent reads from it will return its default value.
  mutating func clearStreamID() {self._streamID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
  fileprivate var _streamID: Int32? = nil
}

struct TvService_CloseStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: TvService_CloseStreamResponse.Result {
    get {return _result ?? .ok}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _result: TvService_CloseStreamResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_CloseStreamResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_GetChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var needIcons: Bool {
    get {return _needIcons ?? false}
    set {_needIcons = newValue}
  }
  /// Returns true if `needIcons` has been explicitly set.
  var hasNeedIcons: Bool {return self._needIcons != nil}
  /// Clears the value of `needIcons`. Subsequent reads from it will return its default value.
  mutating func clearNeedIcons() {self._needIcons = nil}

  var needEpg: Bool {
    get {return _needEpg ?? false}
    set {_needEpg = newValue}
  }
  /// Returns true if `needEpg` has been explicitly set.
  var hasNeedEpg: Bool {return self._needEpg != nil}
  /// Clears the value of `needEpg`. Subsequent reads from it will return its default value.
  mutating func clearNeedEpg() {self._needEpg = nil}

  var needOffsets: Bool {
    get {return _needOffsets ?? false}
    set {_needOffsets = newValue}
  }
  /// Returns true if `needOffsets` has been explicitly set.
  var hasNeedOffsets: Bool {return self._needOffsets != nil}
  /// Clears the value of `needOffsets`. Subsequent reads from it will return its default value.
  mutating func clearNeedOffsets() {self._needOffsets = nil}

  var needCategories: Bool {
    get {return _needCategories ?? false}
    set {_needCategories = newValue}
  }
  /// Returns true if `needCategories` has been explicitly set.
  var hasNeedCategories: Bool {return self._needCategories != nil}
  /// Clears the value of `needCategories`. Subsequent reads from it will return its default value.
  mutating func clearNeedCategories() {self._needCategories = nil}

  var needHash: Bool {
    get {return _needHash ?? false}
    set {_needHash = newValue}
  }
  /// Returns true if `needHash` has been explicitly set.
  var hasNeedHash: Bool {return self._needHash != nil}
  /// Clears the value of `needHash`. Subsequent reads from it will return its default value.
  mutating func clearNeedHash() {self._needHash = nil}

  var needList: Bool {
    get {return _needList ?? false}
    set {_needList = newValue}
  }
  /// Returns true if `needList` has been explicitly set.
  var hasNeedList: Bool {return self._needList != nil}
  /// Clears the value of `needList`. Subsequent reads from it will return its default value.
  mutating func clearNeedList() {self._needList = nil}

  var channels: [Int32] = []

  var epgStartOffset: Int32 {
    get {return _epgStartOffset ?? 0}
    set {_epgStartOffset = newValue}
  }
  /// Returns true if `epgStartOffset` has been explicitly set.
  var hasEpgStartOffset: Bool {return self._epgStartOffset != nil}
  /// Clears the value of `epgStartOffset`. Subsequent reads from it will return its default value.
  mutating func clearEpgStartOffset() {self._epgStartOffset = nil}

  var epgStopOffset: Int32 {
    get {return _epgStopOffset ?? 0}
    set {_epgStopOffset = newValue}
  }
  /// Returns true if `epgStopOffset` has been explicitly set.
  var hasEpgStopOffset: Bool {return self._epgStopOffset != nil}
  /// Clears the value of `epgStopOffset`. Subsequent reads from it will return its default value.
  mutating func clearEpgStopOffset() {self._epgStopOffset = nil}

  var epgLimitPrev: Int32 {
    get {return _epgLimitPrev ?? 0}
    set {_epgLimitPrev = newValue}
  }
  /// Returns true if `epgLimitPrev` has been explicitly set.
  var hasEpgLimitPrev: Bool {return self._epgLimitPrev != nil}
  /// Clears the value of `epgLimitPrev`. Subsequent reads from it will return its default value.
  mutating func clearEpgLimitPrev() {self._epgLimitPrev = nil}

  var epgLimitNext: Int32 {
    get {return _epgLimitNext ?? 0}
    set {_epgLimitNext = newValue}
  }
  /// Returns true if `epgLimitNext` has been explicitly set.
  var hasEpgLimitNext: Bool {return self._epgLimitNext != nil}
  /// Clears the value of `epgLimitNext`. Subsequent reads from it will return its default value.
  mutating func clearEpgLimitNext() {self._epgLimitNext = nil}

  var epgCurrentTime: UInt64 {
    get {return _epgCurrentTime ?? 0}
    set {_epgCurrentTime = newValue}
  }
  /// Returns true if `epgCurrentTime` has been explicitly set.
  var hasEpgCurrentTime: Bool {return self._epgCurrentTime != nil}
  /// Clears the value of `epgCurrentTime`. Subsequent reads from it will return its default value.
  mutating func clearEpgCurrentTime() {self._epgCurrentTime = nil}

  var category: [Int32] = []

  var needBigIcons: Bool {
    get {return _needBigIcons ?? false}
    set {_needBigIcons = newValue}
  }
  /// Returns true if `needBigIcons` has been explicitly set.
  var hasNeedBigIcons: Bool {return self._needBigIcons != nil}
  /// Clears the value of `needBigIcons`. Subsequent reads from it will return its default value.
  mutating func clearNeedBigIcons() {self._needBigIcons = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
  fileprivate var _needIcons: Bool? = nil
  fileprivate var _needEpg: Bool? = nil
  fileprivate var _needOffsets: Bool? = nil
  fileprivate var _needCategories: Bool? = nil
  fileprivate var _needHash: Bool? = nil
  fileprivate var _needList: Bool? = nil
  fileprivate var _epgStartOffset: Int32? = nil
  fileprivate var _epgStopOffset: Int32? = nil
  fileprivate var _epgLimitPrev: Int32? = nil
  fileprivate var _epgLimitNext: Int32? = nil
  fileprivate var _epgCurrentTime: UInt64? = nil
  fileprivate var _needBigIcons: Bool? = nil
}

struct TvService_GetChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: TvService_GetChannelsResponse.Result {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var list: [TvService_Channel] = []

  var offsets: [TvService_TimeOffset] = []

  var categories: [TvService_Category] = []

  var listHash: String {
    get {return _listHash ?? String()}
    set {_listHash = newValue}
  }
  /// Returns true if `listHash` has been explicitly set.
  var hasListHash: Bool {return self._listHash != nil}
  /// Clears the value of `listHash`. Subsequent reads from it will return its default value.
  mutating func clearListHash() {self._listHash = nil}

  var listIDHash: String {
    get {return _listIDHash ?? String()}
    set {_listIDHash = newValue}
  }
  /// Returns true if `listIDHash` has been explicitly set.
  var hasListIDHash: Bool {return self._listIDHash != nil}
  /// Clears the value of `listIDHash`. Subsequent reads from it will return its default value.
  mutating func clearListIDHash() {self._listIDHash = nil}

  var epgURL: String {
    get {return _epgURL ?? String()}
    set {_epgURL = newValue}
  }
  /// Returns true if `epgURL` has been explicitly set.
  var hasEpgURL: Bool {return self._epgURL != nil}
  /// Clears the value of `epgURL`. Subsequent reads from it will return its default value.
  mutating func clearEpgURL() {self._epgURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _status: TvService_GetChannelsResponse.Result? = nil
  fileprivate var _listHash: String? = nil
  fileprivate var _listIDHash: String? = nil
  fileprivate var _epgURL: String? = nil
}

#if swift(>=4.2)

extension TvService_GetChannelsResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_GetTariffsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
}

struct TvService_GetTariffsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: TvService_GetTariffsResponse.Result {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var tariffs: [TvService_Tariff] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _status: TvService_GetTariffsResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_GetTariffsResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_GetSubscriptionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
}

struct TvService_GetSubscriptionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: TvService_GetSubscriptionsResponse.Result {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var subscriptions: [TvService_Subscription] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _status: TvService_GetSubscriptionsResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_GetSubscriptionsResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_GetTariffsOffersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
}

struct TvService_GetTariffsOffersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: TvService_GetTariffsOffersResponse.Result {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var tariffID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _status: TvService_GetTariffsOffersResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_GetTariffsOffersResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_UserChannelData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: [Int32] = []

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enabled: Bool? = nil
}

struct TvService_UserChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var useShared: Bool {
    get {return _useShared ?? false}
    set {_useShared = newValue}
  }
  /// Returns true if `useShared` has been explicitly set.
  var hasUseShared: Bool {return self._useShared != nil}
  /// Clears the value of `useShared`. Subsequent reads from it will return its default value.
  mutating func clearUseShared() {self._useShared = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
  fileprivate var _useShared: Bool? = nil
}

struct TvService_UserChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: TvService_UserChannelResponse.Result {
    get {return _result ?? .ok}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var data: TvService_UserChannelData {
    get {return _data ?? TvService_UserChannelData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _result: TvService_UserChannelResponse.Result? = nil
  fileprivate var _data: TvService_UserChannelData? = nil
}

#if swift(>=4.2)

extension TvService_UserChannelResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_SetUserChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var data: TvService_UserChannelData {
    get {return _data ?? TvService_UserChannelData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var useShared: Bool {
    get {return _useShared ?? false}
    set {_useShared = newValue}
  }
  /// Returns true if `useShared` has been explicitly set.
  var hasUseShared: Bool {return self._useShared != nil}
  /// Clears the value of `useShared`. Subsequent reads from it will return its default value.
  mutating func clearUseShared() {self._useShared = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
  fileprivate var _data: TvService_UserChannelData? = nil
  fileprivate var _useShared: Bool? = nil
}

struct TvService_SetUserChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: TvService_SetUserChannelResponse.Result {
    get {return _result ?? .ok}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      }
    }

  }

  init() {}

  fileprivate var _result: TvService_SetUserChannelResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_SetUserChannelResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct TvService_GetMyVouchersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: String {
    get {return _auth ?? String()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: String? = nil
}

struct TvService_GetMyVouchersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: TvService_GetMyVouchersResponse.Result {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var vouchers: [TvService_Voucher] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noAuth // = 1
    case noVouchersFound // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noAuth
      case 2: self = .noVouchersFound
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noAuth: return 1
      case .noVouchersFound: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: TvService_GetMyVouchersResponse.Result? = nil
}

#if swift(>=4.2)

extension TvService_GetMyVouchersResponse.Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tv_service"

extension TvService_Voucher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Voucher"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "activation_date"),
    3: .standard(proto: "expiration_date"),
    4: .standard(proto: "package_id"),
    5: .standard(proto: "tariff_id"),
  ]

  public var isInitialized: Bool {
    if self._code == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._code) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._activationDate) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._expirationDate) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._packageID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._tariffID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._code {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._activationDate {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._expirationDate {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._packageID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._tariffID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_Voucher, rhs: TvService_Voucher) -> Bool {
    if lhs._code != rhs._code {return false}
    if lhs._activationDate != rhs._activationDate {return false}
    if lhs._expirationDate != rhs._expirationDate {return false}
    if lhs._packageID != rhs._packageID {return false}
    if lhs._tariffID != rhs._tariffID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_OpenStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "offset_id"),
    4: .standard(proto: "accept_scheme"),
    5: .standard(proto: "first_batch_size"),
    6: .standard(proto: "epg_id"),
    7: .same(proto: "multistream"),
    8: .standard(proto: "preview_mode"),
    9: .standard(proto: "pin_code"),
  ]

  public var isInitialized: Bool {
    if self._channelID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._channelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._offsetID) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.acceptScheme) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._firstBatchSize) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._epgID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._multistream) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._previewMode) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._pinCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._channelID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._offsetID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if !self.acceptScheme.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.acceptScheme, fieldNumber: 4)
    }
    if let v = self._firstBatchSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._epgID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._multistream {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    if let v = self._previewMode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    if let v = self._pinCode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_OpenStreamRequest, rhs: TvService_OpenStreamRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs._offsetID != rhs._offsetID {return false}
    if lhs.acceptScheme != rhs.acceptScheme {return false}
    if lhs._firstBatchSize != rhs._firstBatchSize {return false}
    if lhs._epgID != rhs._epgID {return false}
    if lhs._multistream != rhs._multistream {return false}
    if lhs._previewMode != rhs._previewMode {return false}
    if lhs._pinCode != rhs._pinCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_OpenStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "scheme"),
    3: .standard(proto: "multicast_group"),
    4: .standard(proto: "http_stream"),
    5: .standard(proto: "unicast_stream"),
    6: .standard(proto: "cache_server"),
    7: .standard(proto: "stream_id"),
    8: .standard(proto: "update_interval"),
    9: .standard(proto: "license_server"),
    10: .same(proto: "mesh"),
    11: .standard(proto: "content_key"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    if let v = self._multicastGroup, !v.isInitialized {return false}
    if let v = self._httpStream, !v.isInitialized {return false}
    if let v = self._unicastStream, !v.isInitialized {return false}
    if let v = self._cacheServer, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._scheme) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._multicastGroup) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._httpStream) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._unicastStream) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cacheServer) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._streamID) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._updateInterval) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._licenseServer) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._mesh) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._contentKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._scheme {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._multicastGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._httpStream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._unicastStream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._cacheServer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._streamID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._updateInterval {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._licenseServer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if let v = self._mesh {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }
    if let v = self._contentKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_OpenStreamResponse, rhs: TvService_OpenStreamResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._scheme != rhs._scheme {return false}
    if lhs._multicastGroup != rhs._multicastGroup {return false}
    if lhs._httpStream != rhs._httpStream {return false}
    if lhs._unicastStream != rhs._unicastStream {return false}
    if lhs._cacheServer != rhs._cacheServer {return false}
    if lhs._streamID != rhs._streamID {return false}
    if lhs._updateInterval != rhs._updateInterval {return false}
    if lhs._licenseServer != rhs._licenseServer {return false}
    if lhs._mesh != rhs._mesh {return false}
    if lhs._contentKey != rhs._contentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_OpenStreamResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
    2: .same(proto: "NotFound"),
    3: .same(proto: "Deny"),
  ]
}

extension TvService_UpdateStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "stream_id"),
  ]

  public var isInitialized: Bool {
    if self._streamID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._streamID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._streamID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_UpdateStreamRequest, rhs: TvService_UpdateStreamRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._streamID != rhs._streamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_UpdateStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_UpdateStreamResponse, rhs: TvService_UpdateStreamResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_UpdateStreamResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
    2: .same(proto: "ReopenStream"),
    3: .same(proto: "NotFound"),
  ]
}

extension TvService_CloseStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "stream_id"),
  ]

  public var isInitialized: Bool {
    if self._streamID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._streamID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._streamID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_CloseStreamRequest, rhs: TvService_CloseStreamRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._streamID != rhs._streamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_CloseStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_CloseStreamResponse, rhs: TvService_CloseStreamResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_CloseStreamResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_GetChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "need_icons"),
    3: .standard(proto: "need_epg"),
    4: .standard(proto: "need_offsets"),
    8: .standard(proto: "need_categories"),
    12: .standard(proto: "need_hash"),
    13: .standard(proto: "need_list"),
    5: .same(proto: "channels"),
    6: .standard(proto: "epg_start_offset"),
    7: .standard(proto: "epg_stop_offset"),
    10: .standard(proto: "epg_limit_prev"),
    11: .standard(proto: "epg_limit_next"),
    14: .standard(proto: "epg_current_time"),
    9: .same(proto: "category"),
    15: .standard(proto: "need_big_icons"),
  ]

  public var isInitialized: Bool {
    if self._needIcons == nil {return false}
    if self._needEpg == nil {return false}
    if self._needOffsets == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._needIcons) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._needEpg) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._needOffsets) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.channels) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._epgStartOffset) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._epgStopOffset) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._needCategories) }()
      case 9: try { try decoder.decodeRepeatedInt32Field(value: &self.category) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._epgLimitPrev) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._epgLimitNext) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._needHash) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._needList) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self._epgCurrentTime) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self._needBigIcons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._needIcons {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._needEpg {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._needOffsets {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.channels, fieldNumber: 5)
    }
    if let v = self._epgStartOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._epgStopOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._needCategories {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    if !self.category.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.category, fieldNumber: 9)
    }
    if let v = self._epgLimitPrev {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._epgLimitNext {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    }
    if let v = self._needHash {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }
    if let v = self._needList {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    }
    if let v = self._epgCurrentTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
    }
    if let v = self._needBigIcons {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetChannelsRequest, rhs: TvService_GetChannelsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._needIcons != rhs._needIcons {return false}
    if lhs._needEpg != rhs._needEpg {return false}
    if lhs._needOffsets != rhs._needOffsets {return false}
    if lhs._needCategories != rhs._needCategories {return false}
    if lhs._needHash != rhs._needHash {return false}
    if lhs._needList != rhs._needList {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs._epgStartOffset != rhs._epgStartOffset {return false}
    if lhs._epgStopOffset != rhs._epgStopOffset {return false}
    if lhs._epgLimitPrev != rhs._epgLimitPrev {return false}
    if lhs._epgLimitNext != rhs._epgLimitNext {return false}
    if lhs._epgCurrentTime != rhs._epgCurrentTime {return false}
    if lhs.category != rhs.category {return false}
    if lhs._needBigIcons != rhs._needBigIcons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "list"),
    3: .same(proto: "offsets"),
    4: .same(proto: "categories"),
    5: .standard(proto: "list_hash"),
    6: .standard(proto: "list_id_hash"),
    7: .standard(proto: "epg_url"),
  ]

  public var isInitialized: Bool {
    if self._status == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.list) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.offsets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.categories) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.offsets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._listHash) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._listIDHash) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._epgURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 2)
    }
    if !self.offsets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.offsets, fieldNumber: 3)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 4)
    }
    if let v = self._listHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._listIDHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._epgURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetChannelsResponse, rhs: TvService_GetChannelsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.list != rhs.list {return false}
    if lhs.offsets != rhs.offsets {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs._listHash != rhs._listHash {return false}
    if lhs._listIDHash != rhs._listIDHash {return false}
    if lhs._epgURL != rhs._epgURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetChannelsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_GetTariffsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTariffsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetTariffsRequest, rhs: TvService_GetTariffsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetTariffsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTariffsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "tariffs"),
  ]

  public var isInitialized: Bool {
    if self._status == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tariffs) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tariffs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.tariffs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tariffs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetTariffsResponse, rhs: TvService_GetTariffsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.tariffs != rhs.tariffs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetTariffsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_GetSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSubscriptionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetSubscriptionsRequest, rhs: TvService_GetSubscriptionsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSubscriptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "subscriptions"),
  ]

  public var isInitialized: Bool {
    if self._status == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.subscriptions) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetSubscriptionsResponse, rhs: TvService_GetSubscriptionsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetSubscriptionsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_GetTariffsOffersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTariffsOffersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetTariffsOffersRequest, rhs: TvService_GetTariffsOffersRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetTariffsOffersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTariffsOffersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "tariff_id"),
  ]

  public var isInitialized: Bool {
    if self._status == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.tariffID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.tariffID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.tariffID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetTariffsOffersResponse, rhs: TvService_GetTariffsOffersResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.tariffID != rhs.tariffID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetTariffsOffersResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_UserChannelData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserChannelData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "enabled"),
  ]

  public var isInitialized: Bool {
    if self._enabled == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.channelID, fieldNumber: 1)
    }
    if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_UserChannelData, rhs: TvService_UserChannelData) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_UserChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "use_shared"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._useShared) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._useShared {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_UserChannelRequest, rhs: TvService_UserChannelRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._useShared != rhs._useShared {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_UserChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserChannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_UserChannelResponse, rhs: TvService_UserChannelResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_UserChannelResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_SetUserChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetUserChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .same(proto: "data"),
    3: .standard(proto: "use_shared"),
  ]

  public var isInitialized: Bool {
    if self._data == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._useShared) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._useShared {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_SetUserChannelRequest, rhs: TvService_SetUserChannelRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._data != rhs._data {return false}
    if lhs._useShared != rhs._useShared {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_SetUserChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetUserChannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public var isInitialized: Bool {
    if self._result == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_SetUserChannelResponse, rhs: TvService_SetUserChannelResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_SetUserChannelResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
  ]
}

extension TvService_GetMyVouchersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMyVouchersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._auth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetMyVouchersRequest, rhs: TvService_GetMyVouchersRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetMyVouchersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMyVouchersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "vouchers"),
  ]

  public var isInitialized: Bool {
    if self._status == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.vouchers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.vouchers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.vouchers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vouchers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TvService_GetMyVouchersResponse, rhs: TvService_GetMyVouchersResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.vouchers != rhs.vouchers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TvService_GetMyVouchersResponse.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NoAuth"),
    2: .same(proto: "NoVouchersFound"),
  ]
}
